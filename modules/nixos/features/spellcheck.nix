# System-wide spell checking (aspell + hunspell)
{ config, lib, pkgs, ... }:

let
  cfg = config.myModules.nixos.features.spellcheck;

  # Mapping locale → aspell dictionaries
  aspellDictMap = {
    en_CA = [ "en" "en-computers" "en-science" ];
    en_US = [ "en" "en-computers" "en-science" ];
    en_GB = [ "en" "en-computers" ];
    fr_FR = [ "fr" ];
    fr_CA = [ "fr" ];
    es_ES = [ "es" ];
  };

  # Mapping locale → hunspell dictionaries
  hunspellDictMap = {
    en_CA = "en_CA";
    en_US = "en_US";
    en_GB = "en_GB-large";
    fr_FR = "fr-moderne";
    fr_CA = "fr-moderne";  # No specific fr_CA available
    es_ES = "es_ES";
  };

  # Resolve requested aspell dictionaries
  resolvedAspellDicts = lib.flatten (
    map (lang:
      let
        dicts = aspellDictMap.${lang} or [];
      in
        map (dict: pkgs.aspellDicts.${dict} or null) dicts
    ) cfg.languages
  );

  # Filter nulls (unavailable languages)
  availableAspellDicts = lib.filter (d: d != null) resolvedAspellDicts;

  # Resolve hunspell dictionaries
  resolvedHunspellDicts = map (lang:
    let
      dictName = hunspellDictMap.${lang} or null;
    in
      if dictName != null
      then pkgs.hunspellDicts.${dictName} or null
      else null
  ) cfg.languages;

  availableHunspellDicts = lib.filter (d: d != null) resolvedHunspellDicts;

  # Generate aspell config automatically
  aspellMasterLang = lib.head (
    (lib.filter (lang: lib.hasPrefix "en" lang) cfg.languages)
    ++ cfg.languages
  );

  aspellExtraDicts = lib.tail (
    map (lang: aspellDictMap.${lang} or []) cfg.languages
  );

in
{
  options.myModules.nixos.features.spellcheck = {
    enable = lib.mkEnableOption "system-wide spell checking";

    backend = lib.mkOption {
      type = lib.types.enum [ "aspell" "hunspell" "both" ];
      default = "both";
      description = "Spell checking backend to use";
    };

    languages = lib.mkOption {
      type = lib.types.listOf lib.types.str;
      default = [ "en_CA" ];
      example = [ "en_CA" "en_US" "fr_FR" ];
      description = ''
        Language dictionaries to install.
        Format: locale (en_US, fr_FR, etc.)
      '';
    };

    extraAspellDicts = lib.mkOption {
      type = lib.types.listOf lib.types.package;
      default = [];
      example = lib.literalExpression "[ pkgs.aspellDicts.en-science ]";
      description = "Additional aspell dictionaries not in the map";
    };

    extraHunspellDicts = lib.mkOption {
      type = lib.types.listOf lib.types.package;
      default = [];
      description = "Additional hunspell dictionaries not in the map";
    };
  };

  config = lib.mkIf cfg.enable {
    # Validation
    assertions = [
      {
        assertion = cfg.languages != [];
        message = "features.spellcheck.languages cannot be empty";
      }
      {
        assertion = availableAspellDicts != [] || cfg.backend != "aspell";
        message = "No aspell dictionaries found for: ${lib.concatStringsSep ", " cfg.languages}";
      }
    ];

    # Warnings for unsupported languages
    warnings =
      let
        unsupportedAspell = lib.filter (lang: !(lib.hasAttr lang aspellDictMap)) cfg.languages;
        unsupportedHunspell = lib.filter (lang: !(lib.hasAttr lang hunspellDictMap)) cfg.languages;
      in
        (lib.optional (unsupportedAspell != [] && (cfg.backend == "aspell" || cfg.backend == "both"))
          "Aspell: No dictionary mapping for: ${lib.concatStringsSep ", " unsupportedAspell}")
        ++ (lib.optional (unsupportedHunspell != [] && (cfg.backend == "hunspell" || cfg.backend == "both"))
          "Hunspell: No dictionary mapping for: ${lib.concatStringsSep ", " unsupportedHunspell}");

    environment.systemPackages =
      # Aspell
      (lib.optionals (cfg.backend == "aspell" || cfg.backend == "both") (
        [ pkgs.aspell ] ++ availableAspellDicts ++ cfg.extraAspellDicts
      ))
      # Hunspell
      ++ (lib.optionals (cfg.backend == "hunspell" || cfg.backend == "both") (
        [ pkgs.hunspell ] ++ availableHunspellDicts ++ cfg.extraHunspellDicts
      ));

    # Dynamic aspell configuration
    environment.etc."aspell.conf" = lib.mkIf (cfg.backend != "hunspell") {
      text = ''
        # Generated by NixOS features.spellcheck
        master ${aspellMasterLang}
        
        ${lib.concatMapStringsSep "\n" (lang:
          lib.concatMapStringsSep "\n" (dict: "add-extra-dicts ${dict}.rws")
            (aspellDictMap.${lang} or [])
        ) (lib.tail cfg.languages)}
      '';
    };

    # Environment variables for hunspell
    environment.variables = lib.mkIf (cfg.backend != "aspell") {
      DICPATH = lib.makeSearchPath "share/hunspell" availableHunspellDicts;
    };
  };
}
